Solution1은 내 방식으로 푼 코드임

최소 신장 트리를 크루스칼 알고리즘을 이용해 구현한 코드임

크루스칼 알고리즘 과정
1. 그래프의 간선들을 가중치의 오름차순으로 정렬한다.
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.
      * 즉, 가장 낮은 가중치를 먼저 선택한다.
      * 사이클을 형성하는 간선을 제외한다.
3. 해당 간선을 현재의 MST(최소 비용 신장 트리)의 집합에 추가한다.

내 코드는 사이클 여부를 dfs를 통해 직접 검사함

Solution2은 다른 사람의 코드를 보고 구현한 코드임

2차원 배열을 특정 인덱스를 통해 정렬하는 함수형 프로그래밍 방식을 배움

union-find 알고리즘을 배움

union-find 과정
1. make-set(x)
Array[i] = i와 같이 각자 다른 집합 번호로 초기화한다.
2. find(x)
한 번만에 x가 속한 집합 번호를 찾는다.
시간 복잡도: O(1)
3. union(x, y)
배열의 모든 원소를 순회하면서 y의 집합 번호를 x의 집합 번호로 변경한다.
시간 복잡도: O(N)




